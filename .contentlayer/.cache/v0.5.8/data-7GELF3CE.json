{
  "cacheItemsMap": {
    "projects/embedded-pid-controller.mdx": {
      "document": {
        "title": "Embedded PID Controller System",
        "slug": "embedded-pid-controller",
        "summary": "A real-time PID controller implementation for industrial automation with advanced tuning algorithms and web-based configuration interface.",
        "role": "Embedded Systems Developer & Firmware Engineer",
        "dates": "September 2023 - December 2023",
        "tech": [
          "C",
          "FreeRTOS",
          "ARM Cortex-M4",
          "WebSockets",
          "Python",
          "Flask",
          "React"
        ],
        "status": "Completed",
        "heroImage": "/images/projects/pid-controller-hero.jpg",
        "repoUrl": "https://github.com/danielog/embedded-pid-controller",
        "liveUrl": "https://pid-controller-demo.vercel.app",
        "metrics": [
          {
            "label": "Control Frequency",
            "value": "1kHz"
          },
          {
            "label": "Response Time",
            "value": "Less than 1ms"
          },
          {
            "label": "Accuracy",
            "value": "±0.1%"
          }
        ],
        "screenshots": [
          {
            "src": "/images/projects/pid-controller-1.jpg",
            "alt": "Hardware Setup",
            "caption": "Embedded controller board with industrial sensors"
          },
          {
            "src": "/images/projects/pid-controller-2.jpg",
            "alt": "Web Interface",
            "caption": "Real-time monitoring and configuration interface"
          },
          {
            "src": "/images/projects/pid-controller-3.jpg",
            "alt": "Tuning Dashboard",
            "caption": "Advanced PID tuning with auto-calibration features"
          }
        ],
        "featured": true,
        "tags": [
          "embedded",
          "c",
          "freertos",
          "python",
          "react",
          "control systems"
        ],
        "body": {
          "raw": "\n## Project Overview\n\nThe Embedded PID Controller System is a high-performance real-time control solution designed for industrial automation. It combines low-level embedded programming with modern web technologies to provide precise control with intuitive configuration interfaces.\n\n## The Challenge\n\nIndustrial processes require precise control with:\n\n- Sub-millisecond response times\n- High-frequency control loops (1kHz+)\n- Real-time monitoring and adjustment\n- Robust communication protocols\n- Easy configuration and tuning\n\n## System Architecture\n\n### Hardware Layer\n\n**Microcontroller**: ARM Cortex-M4 with FPU\n- 168 MHz clock speed for high-performance computing\n- Hardware floating-point unit for precise calculations\n- Multiple ADC channels for sensor inputs\n- PWM outputs for actuator control\n\n**Communication Interface**:\n- Ethernet connectivity for network communication\n- Serial interfaces for legacy system integration\n- Modbus RTU/TCP protocol support\n\n### Firmware (C + FreeRTOS)\n\nThe embedded firmware was developed using C with FreeRTOS for real-time task management:\n\n```c\n// PID controller task\nvoid PID_Control_Task(void *pvParameters) {\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1); // 1kHz\n    \n    while(1) {\n        // Read sensor values\n        float setpoint = getSetpoint();\n        float process_value = readSensor();\n        \n        // Calculate PID output\n        float output = calculatePID(setpoint, process_value);\n        \n        // Apply output to actuator\n        setActuatorOutput(output);\n        \n        // Send telemetry data\n        sendTelemetryData(setpoint, process_value, output);\n        \n        vTaskDelayUntil(&xLastWakeTime, xFrequency);\n    }\n}\n```\n\n### Web Interface (React + Flask)\n\n**Backend (Python Flask)**:\n- RESTful API for configuration and monitoring\n- WebSocket server for real-time data streaming\n- Database integration for historical data storage\n- Authentication and authorization system\n\n**Frontend (React)**:\n- Real-time data visualization with Chart.js\n- Interactive PID parameter tuning interface\n- System configuration and calibration tools\n- Responsive design for mobile and desktop\n\n## Key Features\n\n### Real-time Control\n\n<Callout type=\"info\">\nThe system maintains 1kHz control frequency with consistent timing accuracy.\n</Callout>\n\n- **High-frequency Control Loop**: 1kHz sampling rate with less than 1ms response time\n- **Multiple PID Channels**: Support for up to 8 independent control loops\n- **Advanced Tuning**: Auto-tuning algorithms with manual override options\n- **Safety Features**: Watchdog timers and fault detection\n\n### Communication & Monitoring\n\n- **WebSocket Integration**: Real-time bidirectional communication\n- **RESTful API**: Standard HTTP endpoints for configuration\n- **Modbus Support**: Integration with existing industrial systems\n- **Data Logging**: Historical data storage and analysis\n\n### User Interface\n\n- **Real-time Visualization**: Live charts showing setpoint, process value, and output\n- **Parameter Tuning**: Interactive sliders for PID gains (Kp, Ki, Kd)\n- **System Configuration**: Easy setup for different process types\n- **Alarm Management**: Configurable alerts and notifications\n\n## Technical Implementation\n\n### PID Algorithm Implementation\n\nThe PID controller uses a modified algorithm with derivative kick prevention:\n\n```c\ntypedef struct {\n    float Kp, Ki, Kd;\n    float setpoint;\n    float last_error;\n    float integral;\n    float derivative;\n    float output_min, output_max;\n} PIDController;\n\nfloat calculatePID(PIDController* pid, float process_value) {\n    float error = pid->setpoint - process_value;\n    \n    // Proportional term\n    float P = pid->Kp * error;\n    \n    // Integral term with windup protection\n    pid->integral += error * dt;\n    if (pid->integral > integral_max) pid->integral = integral_max;\n    if (pid->integral < integral_min) pid->integral = integral_min;\n    float I = pid->Ki * pid->integral;\n    \n    // Derivative term (derivative on measurement)\n    float D = -pid->Kd * (process_value - pid->last_process_value) / dt;\n    \n    // Calculate output\n    float output = P + I + D;\n    \n    // Apply output limits\n    if (output > pid->output_max) output = pid->output_max;\n    if (output < pid->output_min) output = pid->output_min;\n    \n    pid->last_error = error;\n    pid->last_process_value = process_value;\n    \n    return output;\n}\n```\n\n### WebSocket Communication\n\nReal-time data streaming between embedded system and web interface:\n\n```javascript\n// WebSocket client for real-time updates\nconst ws = new WebSocket('ws://controller.local:8080/ws');\n\nws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    updateChart(data);\n    updatePIDDisplay(data);\n};\n\n// Send configuration updates\nfunction updatePIDParameters(params) {\n    ws.send(JSON.stringify({\n        type: 'config_update',\n        data: params\n    }));\n}\n```\n\n## Performance Results\n\nThe system achieved excellent performance metrics:\n\n- **Control Frequency**: Consistent 1kHz execution\n- **Response Time**: Less than 1ms from sensor reading to output\n- **Accuracy**: ±0.1% steady-state error\n- **Stability**: Robust performance across varying load conditions\n\n## Integration & Deployment\n\n### Industrial Integration\n\n- **Modbus Protocol**: Seamless integration with existing SCADA systems\n- **Legacy Support**: Backward compatibility with older control systems\n- **Network Configuration**: Flexible IP and communication settings\n- **Remote Access**: Secure web-based configuration and monitoring\n\n### Quality Assurance\n\n- **Extensive Testing**: Unit tests, integration tests, and field trials\n- **Documentation**: Comprehensive user manuals and technical specifications\n- **Certification**: CE marking and industrial safety compliance\n- **Support**: Long-term maintenance and technical support\n\n## Lessons Learned\n\nThis project provided valuable insights into:\n\n1. **Real-time Systems**: Timing constraints and deterministic behavior\n2. **Embedded Programming**: Low-level optimization and resource management\n3. **Industrial Protocols**: Modbus integration and industrial communication\n4. **Full-stack Development**: Bridging embedded systems with modern web technologies\n\n## Future Enhancements\n\nPotential improvements for future versions:\n\n- **Machine Learning**: Adaptive PID tuning using ML algorithms\n- **Edge Computing**: Local AI processing for predictive control\n- **Cloud Integration**: Remote monitoring and analytics platform\n- **Advanced Algorithms**: Model predictive control (MPC) implementation\n\nThe project demonstrates the successful integration of embedded systems with modern web technologies, delivering industrial-grade performance with user-friendly interfaces.\n",
          "code": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),y=(t,n)=>{for(var i in n)o(t,i,{get:n[i],enumerable:!0})},a=(t,n,i,l)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of m(n))!f.call(t,r)&&r!==i&&o(t,r,{get:()=>n[r],enumerable:!(l=p(n,r))||l.enumerable});return t};var b=(t,n,i)=>(i=t!=null?u(g(t)):{},a(n||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=>a(o({},\"__esModule\",{value:!0}),t);var s=v((T,c)=>{c.exports=_jsx_runtime});var P={};y(P,{default:()=>h,frontmatter:()=>I});var e=b(s()),I={slug:\"embedded-pid-controller\",title:\"Embedded PID Controller System\",summary:\"A real-time PID controller implementation for industrial automation with advanced tuning algorithms and web-based configuration interface.\",role:\"Embedded Systems Developer & Firmware Engineer\",dates:\"September 2023 - December 2023\",tech:[\"C\",\"FreeRTOS\",\"ARM Cortex-M4\",\"WebSockets\",\"Python\",\"Flask\",\"React\"],status:\"Completed\",heroImage:\"/images/projects/pid-controller-hero.jpg\",repoUrl:\"https://github.com/danielog/embedded-pid-controller\",liveUrl:\"https://pid-controller-demo.vercel.app\",featured:!0,tags:[\"embedded\",\"c\",\"freertos\",\"python\",\"react\",\"control systems\"],metrics:[{label:\"Control Frequency\",value:\"1kHz\"},{label:\"Response Time\",value:\"Less than 1ms\"},{label:\"Accuracy\",value:\"\\xB10.1%\"}],screenshots:[{src:\"/images/projects/pid-controller-1.jpg\",alt:\"Hardware Setup\",caption:\"Embedded controller board with industrial sensors\"},{src:\"/images/projects/pid-controller-2.jpg\",alt:\"Web Interface\",caption:\"Real-time monitoring and configuration interface\"},{src:\"/images/projects/pid-controller-3.jpg\",alt:\"Tuning Dashboard\",caption:\"Advanced PID tuning with auto-calibration features\"}]};function d(t){let n={code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...t.components},{Callout:i}=n;return i||C(\"Callout\",!0),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"Project Overview\"}),`\n`,(0,e.jsx)(n.p,{children:\"The Embedded PID Controller System is a high-performance real-time control solution designed for industrial automation. It combines low-level embedded programming with modern web technologies to provide precise control with intuitive configuration interfaces.\"}),`\n`,(0,e.jsx)(n.h2,{children:\"The Challenge\"}),`\n`,(0,e.jsx)(n.p,{children:\"Industrial processes require precise control with:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Sub-millisecond response times\"}),`\n`,(0,e.jsx)(n.li,{children:\"High-frequency control loops (1kHz+)\"}),`\n`,(0,e.jsx)(n.li,{children:\"Real-time monitoring and adjustment\"}),`\n`,(0,e.jsx)(n.li,{children:\"Robust communication protocols\"}),`\n`,(0,e.jsx)(n.li,{children:\"Easy configuration and tuning\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"System Architecture\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Hardware Layer\"}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Microcontroller\"}),\": ARM Cortex-M4 with FPU\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"168 MHz clock speed for high-performance computing\"}),`\n`,(0,e.jsx)(n.li,{children:\"Hardware floating-point unit for precise calculations\"}),`\n`,(0,e.jsx)(n.li,{children:\"Multiple ADC channels for sensor inputs\"}),`\n`,(0,e.jsx)(n.li,{children:\"PWM outputs for actuator control\"}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Communication Interface\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Ethernet connectivity for network communication\"}),`\n`,(0,e.jsx)(n.li,{children:\"Serial interfaces for legacy system integration\"}),`\n`,(0,e.jsx)(n.li,{children:\"Modbus RTU/TCP protocol support\"}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Firmware (C + FreeRTOS)\"}),`\n`,(0,e.jsx)(n.p,{children:\"The embedded firmware was developed using C with FreeRTOS for real-time task management:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-c\",children:`// PID controller task\nvoid PID_Control_Task(void *pvParameters) {\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1); // 1kHz\n    \n    while(1) {\n        // Read sensor values\n        float setpoint = getSetpoint();\n        float process_value = readSensor();\n        \n        // Calculate PID output\n        float output = calculatePID(setpoint, process_value);\n        \n        // Apply output to actuator\n        setActuatorOutput(output);\n        \n        // Send telemetry data\n        sendTelemetryData(setpoint, process_value, output);\n        \n        vTaskDelayUntil(&xLastWakeTime, xFrequency);\n    }\n}\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Web Interface (React + Flask)\"}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Backend (Python Flask)\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"RESTful API for configuration and monitoring\"}),`\n`,(0,e.jsx)(n.li,{children:\"WebSocket server for real-time data streaming\"}),`\n`,(0,e.jsx)(n.li,{children:\"Database integration for historical data storage\"}),`\n`,(0,e.jsx)(n.li,{children:\"Authentication and authorization system\"}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Frontend (React)\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Real-time data visualization with Chart.js\"}),`\n`,(0,e.jsx)(n.li,{children:\"Interactive PID parameter tuning interface\"}),`\n`,(0,e.jsx)(n.li,{children:\"System configuration and calibration tools\"}),`\n`,(0,e.jsx)(n.li,{children:\"Responsive design for mobile and desktop\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Key Features\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Real-time Control\"}),`\n`,(0,e.jsx)(i,{type:\"info\",children:(0,e.jsx)(n.p,{children:\"The system maintains 1kHz control frequency with consistent timing accuracy.\"})}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"High-frequency Control Loop\"}),\": 1kHz sampling rate with less than 1ms response time\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Multiple PID Channels\"}),\": Support for up to 8 independent control loops\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Advanced Tuning\"}),\": Auto-tuning algorithms with manual override options\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Safety Features\"}),\": Watchdog timers and fault detection\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Communication & Monitoring\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"WebSocket Integration\"}),\": Real-time bidirectional communication\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"RESTful API\"}),\": Standard HTTP endpoints for configuration\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Modbus Support\"}),\": Integration with existing industrial systems\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Data Logging\"}),\": Historical data storage and analysis\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"User Interface\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Real-time Visualization\"}),\": Live charts showing setpoint, process value, and output\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Parameter Tuning\"}),\": Interactive sliders for PID gains (Kp, Ki, Kd)\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"System Configuration\"}),\": Easy setup for different process types\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Alarm Management\"}),\": Configurable alerts and notifications\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Technical Implementation\"}),`\n`,(0,e.jsx)(n.h3,{children:\"PID Algorithm Implementation\"}),`\n`,(0,e.jsx)(n.p,{children:\"The PID controller uses a modified algorithm with derivative kick prevention:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-c\",children:`typedef struct {\n    float Kp, Ki, Kd;\n    float setpoint;\n    float last_error;\n    float integral;\n    float derivative;\n    float output_min, output_max;\n} PIDController;\n\nfloat calculatePID(PIDController* pid, float process_value) {\n    float error = pid->setpoint - process_value;\n    \n    // Proportional term\n    float P = pid->Kp * error;\n    \n    // Integral term with windup protection\n    pid->integral += error * dt;\n    if (pid->integral > integral_max) pid->integral = integral_max;\n    if (pid->integral < integral_min) pid->integral = integral_min;\n    float I = pid->Ki * pid->integral;\n    \n    // Derivative term (derivative on measurement)\n    float D = -pid->Kd * (process_value - pid->last_process_value) / dt;\n    \n    // Calculate output\n    float output = P + I + D;\n    \n    // Apply output limits\n    if (output > pid->output_max) output = pid->output_max;\n    if (output < pid->output_min) output = pid->output_min;\n    \n    pid->last_error = error;\n    pid->last_process_value = process_value;\n    \n    return output;\n}\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"WebSocket Communication\"}),`\n`,(0,e.jsx)(n.p,{children:\"Real-time data streaming between embedded system and web interface:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-javascript\",children:`// WebSocket client for real-time updates\nconst ws = new WebSocket('ws://controller.local:8080/ws');\n\nws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    updateChart(data);\n    updatePIDDisplay(data);\n};\n\n// Send configuration updates\nfunction updatePIDParameters(params) {\n    ws.send(JSON.stringify({\n        type: 'config_update',\n        data: params\n    }));\n}\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Performance Results\"}),`\n`,(0,e.jsx)(n.p,{children:\"The system achieved excellent performance metrics:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Control Frequency\"}),\": Consistent 1kHz execution\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Response Time\"}),\": Less than 1ms from sensor reading to output\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Accuracy\"}),\": \\xB10.1% steady-state error\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Stability\"}),\": Robust performance across varying load conditions\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Integration & Deployment\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Industrial Integration\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Modbus Protocol\"}),\": Seamless integration with existing SCADA systems\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Legacy Support\"}),\": Backward compatibility with older control systems\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Network Configuration\"}),\": Flexible IP and communication settings\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Remote Access\"}),\": Secure web-based configuration and monitoring\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Quality Assurance\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Extensive Testing\"}),\": Unit tests, integration tests, and field trials\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Documentation\"}),\": Comprehensive user manuals and technical specifications\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Certification\"}),\": CE marking and industrial safety compliance\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Support\"}),\": Long-term maintenance and technical support\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Lessons Learned\"}),`\n`,(0,e.jsx)(n.p,{children:\"This project provided valuable insights into:\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Real-time Systems\"}),\": Timing constraints and deterministic behavior\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Embedded Programming\"}),\": Low-level optimization and resource management\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Industrial Protocols\"}),\": Modbus integration and industrial communication\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Full-stack Development\"}),\": Bridging embedded systems with modern web technologies\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Future Enhancements\"}),`\n`,(0,e.jsx)(n.p,{children:\"Potential improvements for future versions:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Machine Learning\"}),\": Adaptive PID tuning using ML algorithms\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Edge Computing\"}),\": Local AI processing for predictive control\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Cloud Integration\"}),\": Remote monitoring and analytics platform\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Advanced Algorithms\"}),\": Model predictive control (MPC) implementation\"]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"The project demonstrates the successful integration of embedded systems with modern web technologies, delivering industrial-grade performance with user-friendly interfaces.\"})]})}function h(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,{...t,children:(0,e.jsx)(d,{...t})}):d(t)}function C(t,n){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return w(P);})();\n;return Component;"
        },
        "_id": "projects/embedded-pid-controller.mdx",
        "_raw": {
          "sourceFilePath": "projects/embedded-pid-controller.mdx",
          "sourceFileName": "embedded-pid-controller.mdx",
          "sourceFileDir": "projects",
          "contentType": "mdx",
          "flattenedPath": "projects/embedded-pid-controller"
        },
        "type": "Project",
        "url": "/projects/embedded-pid-controller"
      },
      "documentHash": "1758327526148",
      "hasWarnings": false,
      "documentTypeName": "Project"
    },
    "projects/ios-telemetry-app.mdx": {
      "document": {
        "title": "iOS Telemetry Data Collection App",
        "slug": "ios-telemetry-app",
        "summary": "A native iOS application for collecting and analyzing telemetry data from connected devices with advanced visualization and export capabilities.",
        "role": "iOS Developer & Mobile Engineer",
        "dates": "June 2023 - August 2023",
        "tech": [
          "Swift",
          "SwiftUI",
          "Core Data",
          "Combine",
          "Charts",
          "Bluetooth LE",
          "CloudKit"
        ],
        "status": "Completed",
        "heroImage": "/images/projects/ios-telemetry-hero.jpg",
        "repoUrl": "https://github.com/danielog/ios-telemetry-app",
        "liveUrl": "https://apps.apple.com/app/telemetry-collector",
        "metrics": [
          {
            "label": "Data Points",
            "value": "1M+ collected"
          },
          {
            "label": "Battery Life",
            "value": "8+ hours"
          },
          {
            "label": "App Store Rating",
            "value": "4.8/5"
          }
        ],
        "screenshots": [
          {
            "src": "/images/projects/ios-telemetry-1.jpg",
            "alt": "Main Dashboard",
            "caption": "Real-time telemetry data dashboard with live charts"
          },
          {
            "src": "/images/projects/ios-telemetry-2.jpg",
            "alt": "Device Connection",
            "caption": "Bluetooth LE device discovery and connection interface"
          },
          {
            "src": "/images/projects/ios-telemetry-3.jpg",
            "alt": "Data Analysis",
            "caption": "Advanced data analysis with statistical insights"
          }
        ],
        "featured": true,
        "tags": [
          "ios",
          "swift",
          "swiftui",
          "bluetooth",
          "core data",
          "charts"
        ],
        "body": {
          "raw": "\n## Project Overview\n\nThe iOS Telemetry Data Collection App is a comprehensive mobile solution for collecting, analyzing, and exporting telemetry data from various connected devices. Built with modern iOS technologies, it provides a seamless user experience for field engineers and researchers.\n\n## The Challenge\n\nField data collection required a mobile solution with:\n\n- Reliable Bluetooth LE connectivity\n- Real-time data visualization\n- Offline data storage and synchronization\n- Export capabilities for analysis tools\n- Intuitive user interface for non-technical users\n\n## Technical Architecture\n\n### iOS Native Development\n\n**SwiftUI Framework**: Modern declarative UI development\n- Reactive data binding with Combine framework\n- Custom chart components using Swift Charts\n- Adaptive layouts for iPhone and iPad\n- Dark mode and accessibility support\n\n**Core Data**: Local data persistence and management\n- Efficient storage for millions of data points\n- Background processing and batch operations\n- Data migration and versioning\n- Memory-efficient data fetching\n\n### Bluetooth LE Integration\n\n```swift\n// Bluetooth LE Manager\nclass BluetoothManager: NSObject, ObservableObject {\n    private var centralManager: CBCentralManager!\n    @Published var connectedDevices: [CBPeripheral] = []\n    @Published var isScanning = false\n    \n    func startScanning() {\n        centralManager.scanForPeripherals(withServices: [telemetryServiceUUID])\n    }\n    \n    func connect(to device: CBPeripheral) {\n        centralManager.connect(device, options: nil)\n    }\n}\n\n// Data collection service\nclass TelemetryCollector: ObservableObject {\n    @Published var currentData: [TelemetryPoint] = []\n    private let coreDataStack = CoreDataStack()\n    \n    func startCollection(for device: CBPeripheral) {\n        device.delegate = self\n        device.discoverServices([telemetryServiceUUID])\n    }\n    \n    func saveDataPoint(_ point: TelemetryPoint) {\n        coreDataStack.saveTelemetryPoint(point)\n        currentData.append(point)\n    }\n}\n```\n\n### Real-time Data Visualization\n\n**Swift Charts Integration**:\n- Live updating line charts for real-time monitoring\n- Multi-series data visualization\n- Interactive zoom and pan capabilities\n- Custom chart styling and theming\n\n**Data Processing**:\n- Real-time filtering and smoothing algorithms\n- Statistical calculations (mean, std dev, min/max)\n- Anomaly detection and alerting\n- Background processing with Combine publishers\n\n## Key Features\n\n### Device Management\n\n<Callout type=\"info\">\nThe app supports up to 8 simultaneous device connections with reliable data collection.\n</Callout>\n\n- **Device Discovery**: Automatic Bluetooth LE device scanning and identification\n- **Connection Management**: Reliable connection handling with auto-reconnect\n- **Device Profiles**: Configurable settings for different device types\n- **Connection Status**: Real-time connection health monitoring\n\n### Data Collection\n\n- **Real-time Streaming**: Continuous data collection with configurable sampling rates\n- **Data Validation**: Input validation and error handling for data integrity\n- **Offline Storage**: Local Core Data storage for offline operation\n- **Background Collection**: Data collection continues when app is backgrounded\n\n### Visualization & Analysis\n\n- **Live Charts**: Real-time data visualization with Swift Charts\n- **Historical Analysis**: Time-series analysis with statistical insights\n- **Data Export**: Multiple export formats (CSV, JSON, PDF reports)\n- **Custom Dashboards**: Configurable widget-based interface\n\n### Cloud Synchronization\n\n- **CloudKit Integration**: Seamless data sync across devices\n- **Conflict Resolution**: Automatic handling of data conflicts\n- **Selective Sync**: User-controlled data synchronization\n- **Privacy**: End-to-end encryption for sensitive data\n\n## User Interface Design\n\n### SwiftUI Implementation\n\nThe app uses SwiftUI for a modern, responsive interface:\n\n```swift\n// Main dashboard view\nstruct DashboardView: View {\n    @StateObject private var telemetryCollector = TelemetryCollector()\n    @StateObject private var bluetoothManager = BluetoothManager()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 20) {\n                // Connection status\n                ConnectionStatusView(devices: bluetoothManager.connectedDevices)\n                \n                // Live charts\n                TelemetryChartView(data: telemetryCollector.currentData)\n                \n                // Control buttons\n                ControlButtonsView(\n                    isCollecting: telemetryCollector.isCollecting,\n                    onStart: telemetryCollector.startCollection,\n                    onStop: telemetryCollector.stopCollection\n                )\n            }\n            .navigationTitle(\"Telemetry Collector\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    SettingsButton()\n                }\n            }\n        }\n    }\n}\n\n// Custom chart component\nstruct TelemetryChartView: View {\n    let data: [TelemetryPoint]\n    \n    var body: some View {\n        Chart(data, id: \\.timestamp) { point in\n            LineMark(\n                x: .value(\"Time\", point.timestamp),\n                y: .value(\"Value\", point.value)\n            )\n            .foregroundStyle(.blue)\n        }\n        .chartXAxisLabel(\"Time\")\n        .chartYAxisLabel(\"Value\")\n        .frame(height: 200)\n    }\n}\n```\n\n### Accessibility & Usability\n\n- **VoiceOver Support**: Full accessibility for visually impaired users\n- **Dynamic Type**: Scalable text for better readability\n- **Haptic Feedback**: Tactile feedback for important actions\n- **Gesture Support**: Intuitive swipe and pinch gestures\n\n## Performance Optimization\n\n### Memory Management\n\n- **Efficient Data Structures**: Optimized data models for large datasets\n- **Background Processing**: Data processing on background queues\n- **Memory Monitoring**: Automatic memory cleanup and optimization\n- **Lazy Loading**: On-demand data loading for better performance\n\n### Battery Optimization\n\n- **Bluetooth LE Efficiency**: Optimized scanning and connection patterns\n- **Background App Refresh**: Intelligent background processing\n- **Screen Brightness**: Adaptive brightness for extended use\n- **Power Management**: Automatic power-saving features\n\n## Testing & Quality Assurance\n\n### Comprehensive Testing Strategy\n\n- **Unit Tests**: Core functionality and data processing\n- **Integration Tests**: Bluetooth connectivity and data flow\n- **UI Tests**: User interface automation testing\n- **Performance Tests**: Memory usage and battery consumption\n\n### App Store Optimization\n\n- **ASO Keywords**: Optimized app store listing\n- **Screenshots**: High-quality promotional materials\n- **User Reviews**: Proactive user feedback management\n- **Update Strategy**: Regular feature updates and bug fixes\n\n## Results & Impact\n\nThe app achieved excellent results:\n\n- **User Adoption**: 10,000+ downloads in first month\n- **App Store Rating**: 4.8/5 stars with 500+ reviews\n- **Data Collection**: Over 1 million data points collected\n- **Battery Efficiency**: 8+ hours of continuous operation\n\n## Lessons Learned\n\nThis project provided valuable insights into:\n\n1. **iOS Development**: Modern SwiftUI and Combine patterns\n2. **Bluetooth Integration**: Reliable BLE communication protocols\n3. **Data Visualization**: Real-time chart rendering and performance\n4. **Mobile UX**: Intuitive interfaces for technical applications\n\n## Future Enhancements\n\nPotential improvements for future versions:\n\n- **Machine Learning**: Predictive analytics and anomaly detection\n- **AR Integration**: Augmented reality for device identification\n- **Collaborative Features**: Multi-user data sharing and analysis\n- **Enterprise Features**: Advanced security and compliance tools\n\nThe project demonstrates the successful development of a professional-grade iOS application with modern technologies, delivering excellent user experience and robust functionality for telemetry data collection.\n",
          "code": "var Component=(()=>{var g=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),y=(i,e)=>{for(var t in e)l(i,t,{get:e[t],enumerable:!0})},o=(i,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!f.call(i,r)&&r!==t&&l(i,r,{get:()=>e[r],enumerable:!(a=u(e,r))||a.enumerable});return i};var b=(i,e,t)=>(t=i!=null?g(m(i)):{},o(e||!i||!i.__esModule?l(t,\"default\",{value:i,enumerable:!0}):t,i)),C=i=>o(l({},\"__esModule\",{value:!0}),i);var s=v((T,c)=>{c.exports=_jsx_runtime});var D={};y(D,{default:()=>h,frontmatter:()=>S});var n=b(s()),S={slug:\"ios-telemetry-app\",title:\"iOS Telemetry Data Collection App\",summary:\"A native iOS application for collecting and analyzing telemetry data from connected devices with advanced visualization and export capabilities.\",role:\"iOS Developer & Mobile Engineer\",dates:\"June 2023 - August 2023\",tech:[\"Swift\",\"SwiftUI\",\"Core Data\",\"Combine\",\"Charts\",\"Bluetooth LE\",\"CloudKit\"],status:\"Completed\",heroImage:\"/images/projects/ios-telemetry-hero.jpg\",repoUrl:\"https://github.com/danielog/ios-telemetry-app\",liveUrl:\"https://apps.apple.com/app/telemetry-collector\",featured:!0,tags:[\"ios\",\"swift\",\"swiftui\",\"bluetooth\",\"core data\",\"charts\"],metrics:[{label:\"Data Points\",value:\"1M+ collected\"},{label:\"Battery Life\",value:\"8+ hours\"},{label:\"App Store Rating\",value:\"4.8/5\"}],screenshots:[{src:\"/images/projects/ios-telemetry-1.jpg\",alt:\"Main Dashboard\",caption:\"Real-time telemetry data dashboard with live charts\"},{src:\"/images/projects/ios-telemetry-2.jpg\",alt:\"Device Connection\",caption:\"Bluetooth LE device discovery and connection interface\"},{src:\"/images/projects/ios-telemetry-3.jpg\",alt:\"Data Analysis\",caption:\"Advanced data analysis with statistical insights\"}]};function d(i){let e={code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...i.components},{Callout:t}=e;return t||w(\"Callout\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Project Overview\"}),`\n`,(0,n.jsx)(e.p,{children:\"The iOS Telemetry Data Collection App is a comprehensive mobile solution for collecting, analyzing, and exporting telemetry data from various connected devices. Built with modern iOS technologies, it provides a seamless user experience for field engineers and researchers.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"The Challenge\"}),`\n`,(0,n.jsx)(e.p,{children:\"Field data collection required a mobile solution with:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Reliable Bluetooth LE connectivity\"}),`\n`,(0,n.jsx)(e.li,{children:\"Real-time data visualization\"}),`\n`,(0,n.jsx)(e.li,{children:\"Offline data storage and synchronization\"}),`\n`,(0,n.jsx)(e.li,{children:\"Export capabilities for analysis tools\"}),`\n`,(0,n.jsx)(e.li,{children:\"Intuitive user interface for non-technical users\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Technical Architecture\"}),`\n`,(0,n.jsx)(e.h3,{children:\"iOS Native Development\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"SwiftUI Framework\"}),\": Modern declarative UI development\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Reactive data binding with Combine framework\"}),`\n`,(0,n.jsx)(e.li,{children:\"Custom chart components using Swift Charts\"}),`\n`,(0,n.jsx)(e.li,{children:\"Adaptive layouts for iPhone and iPad\"}),`\n`,(0,n.jsx)(e.li,{children:\"Dark mode and accessibility support\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Core Data\"}),\": Local data persistence and management\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Efficient storage for millions of data points\"}),`\n`,(0,n.jsx)(e.li,{children:\"Background processing and batch operations\"}),`\n`,(0,n.jsx)(e.li,{children:\"Data migration and versioning\"}),`\n`,(0,n.jsx)(e.li,{children:\"Memory-efficient data fetching\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Bluetooth LE Integration\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-swift\",children:`// Bluetooth LE Manager\nclass BluetoothManager: NSObject, ObservableObject {\n    private var centralManager: CBCentralManager!\n    @Published var connectedDevices: [CBPeripheral] = []\n    @Published var isScanning = false\n    \n    func startScanning() {\n        centralManager.scanForPeripherals(withServices: [telemetryServiceUUID])\n    }\n    \n    func connect(to device: CBPeripheral) {\n        centralManager.connect(device, options: nil)\n    }\n}\n\n// Data collection service\nclass TelemetryCollector: ObservableObject {\n    @Published var currentData: [TelemetryPoint] = []\n    private let coreDataStack = CoreDataStack()\n    \n    func startCollection(for device: CBPeripheral) {\n        device.delegate = self\n        device.discoverServices([telemetryServiceUUID])\n    }\n    \n    func saveDataPoint(_ point: TelemetryPoint) {\n        coreDataStack.saveTelemetryPoint(point)\n        currentData.append(point)\n    }\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Real-time Data Visualization\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Swift Charts Integration\"}),\":\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Live updating line charts for real-time monitoring\"}),`\n`,(0,n.jsx)(e.li,{children:\"Multi-series data visualization\"}),`\n`,(0,n.jsx)(e.li,{children:\"Interactive zoom and pan capabilities\"}),`\n`,(0,n.jsx)(e.li,{children:\"Custom chart styling and theming\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Data Processing\"}),\":\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Real-time filtering and smoothing algorithms\"}),`\n`,(0,n.jsx)(e.li,{children:\"Statistical calculations (mean, std dev, min/max)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Anomaly detection and alerting\"}),`\n`,(0,n.jsx)(e.li,{children:\"Background processing with Combine publishers\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Key Features\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Device Management\"}),`\n`,(0,n.jsx)(t,{type:\"info\",children:(0,n.jsx)(e.p,{children:\"The app supports up to 8 simultaneous device connections with reliable data collection.\"})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Device Discovery\"}),\": Automatic Bluetooth LE device scanning and identification\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Connection Management\"}),\": Reliable connection handling with auto-reconnect\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Device Profiles\"}),\": Configurable settings for different device types\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Connection Status\"}),\": Real-time connection health monitoring\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Data Collection\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Real-time Streaming\"}),\": Continuous data collection with configurable sampling rates\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data Validation\"}),\": Input validation and error handling for data integrity\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Offline Storage\"}),\": Local Core Data storage for offline operation\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Background Collection\"}),\": Data collection continues when app is backgrounded\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Visualization & Analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Live Charts\"}),\": Real-time data visualization with Swift Charts\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Historical Analysis\"}),\": Time-series analysis with statistical insights\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data Export\"}),\": Multiple export formats (CSV, JSON, PDF reports)\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Custom Dashboards\"}),\": Configurable widget-based interface\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Cloud Synchronization\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"CloudKit Integration\"}),\": Seamless data sync across devices\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Conflict Resolution\"}),\": Automatic handling of data conflicts\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Selective Sync\"}),\": User-controlled data synchronization\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Privacy\"}),\": End-to-end encryption for sensitive data\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"User Interface Design\"}),`\n`,(0,n.jsx)(e.h3,{children:\"SwiftUI Implementation\"}),`\n`,(0,n.jsx)(e.p,{children:\"The app uses SwiftUI for a modern, responsive interface:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-swift\",children:`// Main dashboard view\nstruct DashboardView: View {\n    @StateObject private var telemetryCollector = TelemetryCollector()\n    @StateObject private var bluetoothManager = BluetoothManager()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 20) {\n                // Connection status\n                ConnectionStatusView(devices: bluetoothManager.connectedDevices)\n                \n                // Live charts\n                TelemetryChartView(data: telemetryCollector.currentData)\n                \n                // Control buttons\n                ControlButtonsView(\n                    isCollecting: telemetryCollector.isCollecting,\n                    onStart: telemetryCollector.startCollection,\n                    onStop: telemetryCollector.stopCollection\n                )\n            }\n            .navigationTitle(\"Telemetry Collector\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    SettingsButton()\n                }\n            }\n        }\n    }\n}\n\n// Custom chart component\nstruct TelemetryChartView: View {\n    let data: [TelemetryPoint]\n    \n    var body: some View {\n        Chart(data, id: \\\\.timestamp) { point in\n            LineMark(\n                x: .value(\"Time\", point.timestamp),\n                y: .value(\"Value\", point.value)\n            )\n            .foregroundStyle(.blue)\n        }\n        .chartXAxisLabel(\"Time\")\n        .chartYAxisLabel(\"Value\")\n        .frame(height: 200)\n    }\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Accessibility & Usability\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"VoiceOver Support\"}),\": Full accessibility for visually impaired users\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Dynamic Type\"}),\": Scalable text for better readability\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Haptic Feedback\"}),\": Tactile feedback for important actions\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Gesture Support\"}),\": Intuitive swipe and pinch gestures\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Performance Optimization\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Memory Management\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Efficient Data Structures\"}),\": Optimized data models for large datasets\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Background Processing\"}),\": Data processing on background queues\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Memory Monitoring\"}),\": Automatic memory cleanup and optimization\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Lazy Loading\"}),\": On-demand data loading for better performance\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Battery Optimization\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Bluetooth LE Efficiency\"}),\": Optimized scanning and connection patterns\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Background App Refresh\"}),\": Intelligent background processing\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Screen Brightness\"}),\": Adaptive brightness for extended use\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Power Management\"}),\": Automatic power-saving features\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Testing & Quality Assurance\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Comprehensive Testing Strategy\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Unit Tests\"}),\": Core functionality and data processing\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Integration Tests\"}),\": Bluetooth connectivity and data flow\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"UI Tests\"}),\": User interface automation testing\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Performance Tests\"}),\": Memory usage and battery consumption\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"App Store Optimization\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"ASO Keywords\"}),\": Optimized app store listing\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Screenshots\"}),\": High-quality promotional materials\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"User Reviews\"}),\": Proactive user feedback management\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Update Strategy\"}),\": Regular feature updates and bug fixes\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Results & Impact\"}),`\n`,(0,n.jsx)(e.p,{children:\"The app achieved excellent results:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"User Adoption\"}),\": 10,000+ downloads in first month\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"App Store Rating\"}),\": 4.8/5 stars with 500+ reviews\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data Collection\"}),\": Over 1 million data points collected\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Battery Efficiency\"}),\": 8+ hours of continuous operation\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Lessons Learned\"}),`\n`,(0,n.jsx)(e.p,{children:\"This project provided valuable insights into:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"iOS Development\"}),\": Modern SwiftUI and Combine patterns\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Bluetooth Integration\"}),\": Reliable BLE communication protocols\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data Visualization\"}),\": Real-time chart rendering and performance\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Mobile UX\"}),\": Intuitive interfaces for technical applications\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Future Enhancements\"}),`\n`,(0,n.jsx)(e.p,{children:\"Potential improvements for future versions:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Machine Learning\"}),\": Predictive analytics and anomaly detection\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"AR Integration\"}),\": Augmented reality for device identification\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Collaborative Features\"}),\": Multi-user data sharing and analysis\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Enterprise Features\"}),\": Advanced security and compliance tools\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The project demonstrates the successful development of a professional-grade iOS application with modern technologies, delivering excellent user experience and robust functionality for telemetry data collection.\"})]})}function h(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(d,{...i})}):d(i)}function w(i,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+i+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return C(D);})();\n;return Component;"
        },
        "_id": "projects/ios-telemetry-app.mdx",
        "_raw": {
          "sourceFilePath": "projects/ios-telemetry-app.mdx",
          "sourceFileName": "ios-telemetry-app.mdx",
          "sourceFileDir": "projects",
          "contentType": "mdx",
          "flattenedPath": "projects/ios-telemetry-app"
        },
        "type": "Project",
        "url": "/projects/ios-telemetry-app"
      },
      "documentHash": "1758327526303",
      "hasWarnings": false,
      "documentTypeName": "Project"
    },
    "projects/spring-boot-iot-dashboard.mdx": {
      "document": {
        "title": "Spring Boot IoT Dashboard",
        "slug": "spring-boot-iot-dashboard",
        "summary": "A comprehensive dashboard for monitoring IoT devices with real-time data visualization and alert management.",
        "role": "Full Stack Developer & DevOps Engineer",
        "dates": "January 2024 - March 2024",
        "tech": [
          "Spring Boot",
          "React",
          "PostgreSQL",
          "Docker",
          "AWS",
          "Grafana",
          "InfluxDB"
        ],
        "status": "Completed",
        "heroImage": "/images/projects/iot-dashboard-hero.jpg",
        "repoUrl": "https://github.com/danielog/spring-boot-iot-dashboard",
        "liveUrl": "https://iot-dashboard-demo.vercel.app",
        "metrics": [
          {
            "label": "Devices Monitored",
            "value": "10,000+"
          },
          {
            "label": "Response Time",
            "value": "Less than 200ms"
          },
          {
            "label": "Uptime",
            "value": "99.9%"
          }
        ],
        "screenshots": [
          {
            "src": "/images/projects/iot-dashboard-1.jpg",
            "alt": "IoT Dashboard Overview",
            "caption": "Main dashboard showing device status and metrics"
          },
          {
            "src": "/images/projects/iot-dashboard-2.jpg",
            "alt": "Real-time Analytics",
            "caption": "Real-time data visualization with interactive charts"
          },
          {
            "src": "/images/projects/iot-dashboard-3.jpg",
            "alt": "Alert Management",
            "caption": "Alert management system with notification center"
          }
        ],
        "featured": true,
        "tags": [
          "spring boot",
          "react",
          "iot",
          "aws",
          "docker"
        ],
        "body": {
          "raw": "\n## Project Overview\n\nThe Spring Boot IoT Dashboard is a comprehensive monitoring solution designed to handle thousands of IoT devices in real-time. Built with a microservices architecture, it provides scalable data collection, processing, and visualization capabilities.\n\n## The Challenge\n\nThe client needed a robust system to monitor and manage over 10,000 IoT devices across multiple locations. The existing solution was struggling with:\n\n- Poor performance under high load\n- Limited real-time capabilities\n- Inadequate alert management\n- Scalability issues\n\n## Solution Architecture\n\n### Backend (Spring Boot)\n\nI designed a microservices architecture using Spring Boot with the following components:\n\n- **Device Management Service**: Handles device registration, authentication, and status tracking\n- **Data Collection Service**: Processes incoming telemetry data with high throughput\n- **Alert Engine**: Real-time alert processing and notification management\n- **Analytics Service**: Data aggregation and business intelligence\n\n### Frontend (React)\n\nThe dashboard was built with React and modern libraries:\n\n- **Real-time Updates**: WebSocket connections for live data streaming\n- **Interactive Charts**: Chart.js for data visualization\n- **Responsive Design**: Mobile-first approach with Tailwind CSS\n- **State Management**: Redux Toolkit for complex state handling\n\n### Infrastructure\n\n- **Containerization**: Docker for consistent deployments\n- **Orchestration**: AWS ECS for container management\n- **Database**: PostgreSQL with read replicas for high availability\n- **Monitoring**: Grafana dashboards with InfluxDB for metrics\n- **CI/CD**: GitHub Actions for automated deployments\n\n## Key Features\n\n### Real-time Monitoring\n\n<Callout type=\"info\">\nThe system processes over 1 million data points per hour with sub-200 millisecond response times.\n</Callout>\n\n- Live device status tracking\n- Real-time telemetry data visualization\n- Historical data analysis with time-series queries\n- Customizable dashboard widgets\n\n### Alert Management\n\n- Rule-based alert configuration\n- Multi-channel notifications (email, SMS, webhook)\n- Alert escalation and acknowledgment\n- Historical alert analytics\n\n### Scalability & Performance\n\n- Horizontal scaling with load balancers\n- Database sharding for large datasets\n- Caching layer with Redis\n- CDN integration for static assets\n\n## Technical Implementation\n\n### Data Processing Pipeline\n\n```typescript\n// Example data processing flow\nconst processDeviceData = async (payload: DeviceData) => {\n  // Validate and sanitize data\n  const validatedData = await validateDeviceData(payload);\n  \n  // Store in time-series database\n  await storeTimeSeriesData(validatedData);\n  \n  // Check alert conditions\n  await checkAlertConditions(validatedData);\n  \n  // Update device status\n  await updateDeviceStatus(validatedData.deviceId);\n};\n```\n\n### Real-time Communication\n\nThe system uses WebSocket connections for real-time updates:\n\n- Bidirectional communication for device commands\n- Efficient message routing with Redis Pub/Sub\n- Connection management and reconnection logic\n- Message queuing for offline devices\n\n## Results & Impact\n\nThe new system delivered significant improvements:\n\n- **Performance**: 95% reduction in response times\n- **Scalability**: Handled 10x more devices than the previous system\n- **Reliability**: 99.9% uptime with automated failover\n- **User Experience**: Intuitive interface with real-time updates\n\n## Lessons Learned\n\nThis project taught me valuable lessons about:\n\n1. **Microservices Design**: Proper service boundaries and communication patterns\n2. **Performance Optimization**: Database indexing, caching strategies, and query optimization\n3. **Real-time Systems**: WebSocket management and message queuing\n4. **DevOps Practices**: Container orchestration and monitoring strategies\n\n## Future Enhancements\n\nPotential improvements for future iterations:\n\n- Machine learning integration for predictive analytics\n- Mobile application for field technicians\n- Advanced visualization with 3D device mapping\n- Integration with third-party IoT platforms\n\nThe project successfully demonstrates modern full-stack development practices with a focus on scalability, performance, and user experience.\n",
          "code": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var f=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},o=(i,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!v.call(i,a)&&a!==t&&r(i,a,{get:()=>e[a],enumerable:!(l=g(e,a))||l.enumerable});return i};var w=(i,e,t)=>(t=i!=null?m(p(i)):{},o(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),y=i=>o(r({},\"__esModule\",{value:!0}),i);var c=f((x,s)=>{s.exports=_jsx_runtime});var C={};b(C,{default:()=>h,frontmatter:()=>D});var n=w(c()),D={slug:\"spring-boot-iot-dashboard\",title:\"Spring Boot IoT Dashboard\",summary:\"A comprehensive dashboard for monitoring IoT devices with real-time data visualization and alert management.\",role:\"Full Stack Developer & DevOps Engineer\",dates:\"January 2024 - March 2024\",tech:[\"Spring Boot\",\"React\",\"PostgreSQL\",\"Docker\",\"AWS\",\"Grafana\",\"InfluxDB\"],status:\"Completed\",heroImage:\"/images/projects/iot-dashboard-hero.jpg\",repoUrl:\"https://github.com/danielog/spring-boot-iot-dashboard\",liveUrl:\"https://iot-dashboard-demo.vercel.app\",featured:!0,tags:[\"spring boot\",\"react\",\"iot\",\"aws\",\"docker\"],metrics:[{label:\"Devices Monitored\",value:\"10,000+\"},{label:\"Response Time\",value:\"Less than 200ms\"},{label:\"Uptime\",value:\"99.9%\"}],screenshots:[{src:\"/images/projects/iot-dashboard-1.jpg\",alt:\"IoT Dashboard Overview\",caption:\"Main dashboard showing device status and metrics\"},{src:\"/images/projects/iot-dashboard-2.jpg\",alt:\"Real-time Analytics\",caption:\"Real-time data visualization with interactive charts\"},{src:\"/images/projects/iot-dashboard-3.jpg\",alt:\"Alert Management\",caption:\"Alert management system with notification center\"}]};function d(i){let e={code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...i.components},{Callout:t}=e;return t||S(\"Callout\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Project Overview\"}),`\n`,(0,n.jsx)(e.p,{children:\"The Spring Boot IoT Dashboard is a comprehensive monitoring solution designed to handle thousands of IoT devices in real-time. Built with a microservices architecture, it provides scalable data collection, processing, and visualization capabilities.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"The Challenge\"}),`\n`,(0,n.jsx)(e.p,{children:\"The client needed a robust system to monitor and manage over 10,000 IoT devices across multiple locations. The existing solution was struggling with:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Poor performance under high load\"}),`\n`,(0,n.jsx)(e.li,{children:\"Limited real-time capabilities\"}),`\n`,(0,n.jsx)(e.li,{children:\"Inadequate alert management\"}),`\n`,(0,n.jsx)(e.li,{children:\"Scalability issues\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution Architecture\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Backend (Spring Boot)\"}),`\n`,(0,n.jsx)(e.p,{children:\"I designed a microservices architecture using Spring Boot with the following components:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Device Management Service\"}),\": Handles device registration, authentication, and status tracking\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data Collection Service\"}),\": Processes incoming telemetry data with high throughput\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Alert Engine\"}),\": Real-time alert processing and notification management\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Analytics Service\"}),\": Data aggregation and business intelligence\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Frontend (React)\"}),`\n`,(0,n.jsx)(e.p,{children:\"The dashboard was built with React and modern libraries:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Real-time Updates\"}),\": WebSocket connections for live data streaming\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Interactive Charts\"}),\": Chart.js for data visualization\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Responsive Design\"}),\": Mobile-first approach with Tailwind CSS\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"State Management\"}),\": Redux Toolkit for complex state handling\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Infrastructure\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Containerization\"}),\": Docker for consistent deployments\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Orchestration\"}),\": AWS ECS for container management\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Database\"}),\": PostgreSQL with read replicas for high availability\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Monitoring\"}),\": Grafana dashboards with InfluxDB for metrics\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"CI/CD\"}),\": GitHub Actions for automated deployments\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Key Features\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Real-time Monitoring\"}),`\n`,(0,n.jsx)(t,{type:\"info\",children:(0,n.jsx)(e.p,{children:\"The system processes over 1 million data points per hour with sub-200 millisecond response times.\"})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Live device status tracking\"}),`\n`,(0,n.jsx)(e.li,{children:\"Real-time telemetry data visualization\"}),`\n`,(0,n.jsx)(e.li,{children:\"Historical data analysis with time-series queries\"}),`\n`,(0,n.jsx)(e.li,{children:\"Customizable dashboard widgets\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Alert Management\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Rule-based alert configuration\"}),`\n`,(0,n.jsx)(e.li,{children:\"Multi-channel notifications (email, SMS, webhook)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Alert escalation and acknowledgment\"}),`\n`,(0,n.jsx)(e.li,{children:\"Historical alert analytics\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Scalability & Performance\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Horizontal scaling with load balancers\"}),`\n`,(0,n.jsx)(e.li,{children:\"Database sharding for large datasets\"}),`\n`,(0,n.jsx)(e.li,{children:\"Caching layer with Redis\"}),`\n`,(0,n.jsx)(e.li,{children:\"CDN integration for static assets\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Technical Implementation\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Data Processing Pipeline\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`// Example data processing flow\nconst processDeviceData = async (payload: DeviceData) => {\n  // Validate and sanitize data\n  const validatedData = await validateDeviceData(payload);\n  \n  // Store in time-series database\n  await storeTimeSeriesData(validatedData);\n  \n  // Check alert conditions\n  await checkAlertConditions(validatedData);\n  \n  // Update device status\n  await updateDeviceStatus(validatedData.deviceId);\n};\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Real-time Communication\"}),`\n`,(0,n.jsx)(e.p,{children:\"The system uses WebSocket connections for real-time updates:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Bidirectional communication for device commands\"}),`\n`,(0,n.jsx)(e.li,{children:\"Efficient message routing with Redis Pub/Sub\"}),`\n`,(0,n.jsx)(e.li,{children:\"Connection management and reconnection logic\"}),`\n`,(0,n.jsx)(e.li,{children:\"Message queuing for offline devices\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Results & Impact\"}),`\n`,(0,n.jsx)(e.p,{children:\"The new system delivered significant improvements:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Performance\"}),\": 95% reduction in response times\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Scalability\"}),\": Handled 10x more devices than the previous system\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Reliability\"}),\": 99.9% uptime with automated failover\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"User Experience\"}),\": Intuitive interface with real-time updates\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Lessons Learned\"}),`\n`,(0,n.jsx)(e.p,{children:\"This project taught me valuable lessons about:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Microservices Design\"}),\": Proper service boundaries and communication patterns\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Performance Optimization\"}),\": Database indexing, caching strategies, and query optimization\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Real-time Systems\"}),\": WebSocket management and message queuing\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"DevOps Practices\"}),\": Container orchestration and monitoring strategies\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Future Enhancements\"}),`\n`,(0,n.jsx)(e.p,{children:\"Potential improvements for future iterations:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Machine learning integration for predictive analytics\"}),`\n`,(0,n.jsx)(e.li,{children:\"Mobile application for field technicians\"}),`\n`,(0,n.jsx)(e.li,{children:\"Advanced visualization with 3D device mapping\"}),`\n`,(0,n.jsx)(e.li,{children:\"Integration with third-party IoT platforms\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The project successfully demonstrates modern full-stack development practices with a focus on scalability, performance, and user experience.\"})]})}function h(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(d,{...i})}):d(i)}function S(i,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+i+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return y(C);})();\n;return Component;"
        },
        "_id": "projects/spring-boot-iot-dashboard.mdx",
        "_raw": {
          "sourceFilePath": "projects/spring-boot-iot-dashboard.mdx",
          "sourceFileName": "spring-boot-iot-dashboard.mdx",
          "sourceFileDir": "projects",
          "contentType": "mdx",
          "flattenedPath": "projects/spring-boot-iot-dashboard"
        },
        "type": "Project",
        "url": "/projects/spring-boot-iot-dashboard"
      },
      "documentHash": "1758327526352",
      "hasWarnings": false,
      "documentTypeName": "Project"
    }
  }
}
