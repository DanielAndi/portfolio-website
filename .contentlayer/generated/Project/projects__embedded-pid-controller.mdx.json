{
  "title": "Embedded PID Controller System",
  "slug": "embedded-pid-controller",
  "summary": "A real-time PID controller implementation for industrial automation with advanced tuning algorithms and web-based configuration interface.",
  "role": "Embedded Systems Developer & Firmware Engineer",
  "dates": "September 2023 - December 2023",
  "tech": [
    "C",
    "FreeRTOS",
    "ARM Cortex-M4",
    "WebSockets",
    "Python",
    "Flask",
    "React"
  ],
  "status": "Completed",
  "heroImage": "/images/projects/pid-controller-hero.jpg",
  "repoUrl": "https://github.com/danielog/embedded-pid-controller",
  "liveUrl": "https://pid-controller-demo.vercel.app",
  "metrics": [
    {
      "label": "Control Frequency",
      "value": "1kHz"
    },
    {
      "label": "Response Time",
      "value": "Less than 1ms"
    },
    {
      "label": "Accuracy",
      "value": "±0.1%"
    }
  ],
  "screenshots": [
    {
      "src": "/images/projects/pid-controller-1.jpg",
      "alt": "Hardware Setup",
      "caption": "Embedded controller board with industrial sensors"
    },
    {
      "src": "/images/projects/pid-controller-2.jpg",
      "alt": "Web Interface",
      "caption": "Real-time monitoring and configuration interface"
    },
    {
      "src": "/images/projects/pid-controller-3.jpg",
      "alt": "Tuning Dashboard",
      "caption": "Advanced PID tuning with auto-calibration features"
    }
  ],
  "featured": true,
  "tags": [
    "embedded",
    "c",
    "freertos",
    "python",
    "react",
    "control systems"
  ],
  "body": {
    "raw": "\n## Project Overview\n\nThe Embedded PID Controller System is a high-performance real-time control solution designed for industrial automation. It combines low-level embedded programming with modern web technologies to provide precise control with intuitive configuration interfaces.\n\n## The Challenge\n\nIndustrial processes require precise control with:\n\n- Sub-millisecond response times\n- High-frequency control loops (1kHz+)\n- Real-time monitoring and adjustment\n- Robust communication protocols\n- Easy configuration and tuning\n\n## System Architecture\n\n### Hardware Layer\n\n**Microcontroller**: ARM Cortex-M4 with FPU\n- 168 MHz clock speed for high-performance computing\n- Hardware floating-point unit for precise calculations\n- Multiple ADC channels for sensor inputs\n- PWM outputs for actuator control\n\n**Communication Interface**:\n- Ethernet connectivity for network communication\n- Serial interfaces for legacy system integration\n- Modbus RTU/TCP protocol support\n\n### Firmware (C + FreeRTOS)\n\nThe embedded firmware was developed using C with FreeRTOS for real-time task management:\n\n```c\n// PID controller task\nvoid PID_Control_Task(void *pvParameters) {\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1); // 1kHz\n    \n    while(1) {\n        // Read sensor values\n        float setpoint = getSetpoint();\n        float process_value = readSensor();\n        \n        // Calculate PID output\n        float output = calculatePID(setpoint, process_value);\n        \n        // Apply output to actuator\n        setActuatorOutput(output);\n        \n        // Send telemetry data\n        sendTelemetryData(setpoint, process_value, output);\n        \n        vTaskDelayUntil(&xLastWakeTime, xFrequency);\n    }\n}\n```\n\n### Web Interface (React + Flask)\n\n**Backend (Python Flask)**:\n- RESTful API for configuration and monitoring\n- WebSocket server for real-time data streaming\n- Database integration for historical data storage\n- Authentication and authorization system\n\n**Frontend (React)**:\n- Real-time data visualization with Chart.js\n- Interactive PID parameter tuning interface\n- System configuration and calibration tools\n- Responsive design for mobile and desktop\n\n## Key Features\n\n### Real-time Control\n\n<Callout type=\"info\">\nThe system maintains 1kHz control frequency with consistent timing accuracy.\n</Callout>\n\n- **High-frequency Control Loop**: 1kHz sampling rate with less than 1ms response time\n- **Multiple PID Channels**: Support for up to 8 independent control loops\n- **Advanced Tuning**: Auto-tuning algorithms with manual override options\n- **Safety Features**: Watchdog timers and fault detection\n\n### Communication & Monitoring\n\n- **WebSocket Integration**: Real-time bidirectional communication\n- **RESTful API**: Standard HTTP endpoints for configuration\n- **Modbus Support**: Integration with existing industrial systems\n- **Data Logging**: Historical data storage and analysis\n\n### User Interface\n\n- **Real-time Visualization**: Live charts showing setpoint, process value, and output\n- **Parameter Tuning**: Interactive sliders for PID gains (Kp, Ki, Kd)\n- **System Configuration**: Easy setup for different process types\n- **Alarm Management**: Configurable alerts and notifications\n\n## Technical Implementation\n\n### PID Algorithm Implementation\n\nThe PID controller uses a modified algorithm with derivative kick prevention:\n\n```c\ntypedef struct {\n    float Kp, Ki, Kd;\n    float setpoint;\n    float last_error;\n    float integral;\n    float derivative;\n    float output_min, output_max;\n} PIDController;\n\nfloat calculatePID(PIDController* pid, float process_value) {\n    float error = pid->setpoint - process_value;\n    \n    // Proportional term\n    float P = pid->Kp * error;\n    \n    // Integral term with windup protection\n    pid->integral += error * dt;\n    if (pid->integral > integral_max) pid->integral = integral_max;\n    if (pid->integral < integral_min) pid->integral = integral_min;\n    float I = pid->Ki * pid->integral;\n    \n    // Derivative term (derivative on measurement)\n    float D = -pid->Kd * (process_value - pid->last_process_value) / dt;\n    \n    // Calculate output\n    float output = P + I + D;\n    \n    // Apply output limits\n    if (output > pid->output_max) output = pid->output_max;\n    if (output < pid->output_min) output = pid->output_min;\n    \n    pid->last_error = error;\n    pid->last_process_value = process_value;\n    \n    return output;\n}\n```\n\n### WebSocket Communication\n\nReal-time data streaming between embedded system and web interface:\n\n```javascript\n// WebSocket client for real-time updates\nconst ws = new WebSocket('ws://controller.local:8080/ws');\n\nws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    updateChart(data);\n    updatePIDDisplay(data);\n};\n\n// Send configuration updates\nfunction updatePIDParameters(params) {\n    ws.send(JSON.stringify({\n        type: 'config_update',\n        data: params\n    }));\n}\n```\n\n## Performance Results\n\nThe system achieved excellent performance metrics:\n\n- **Control Frequency**: Consistent 1kHz execution\n- **Response Time**: Less than 1ms from sensor reading to output\n- **Accuracy**: ±0.1% steady-state error\n- **Stability**: Robust performance across varying load conditions\n\n## Integration & Deployment\n\n### Industrial Integration\n\n- **Modbus Protocol**: Seamless integration with existing SCADA systems\n- **Legacy Support**: Backward compatibility with older control systems\n- **Network Configuration**: Flexible IP and communication settings\n- **Remote Access**: Secure web-based configuration and monitoring\n\n### Quality Assurance\n\n- **Extensive Testing**: Unit tests, integration tests, and field trials\n- **Documentation**: Comprehensive user manuals and technical specifications\n- **Certification**: CE marking and industrial safety compliance\n- **Support**: Long-term maintenance and technical support\n\n## Lessons Learned\n\nThis project provided valuable insights into:\n\n1. **Real-time Systems**: Timing constraints and deterministic behavior\n2. **Embedded Programming**: Low-level optimization and resource management\n3. **Industrial Protocols**: Modbus integration and industrial communication\n4. **Full-stack Development**: Bridging embedded systems with modern web technologies\n\n## Future Enhancements\n\nPotential improvements for future versions:\n\n- **Machine Learning**: Adaptive PID tuning using ML algorithms\n- **Edge Computing**: Local AI processing for predictive control\n- **Cloud Integration**: Remote monitoring and analytics platform\n- **Advanced Algorithms**: Model predictive control (MPC) implementation\n\nThe project demonstrates the successful integration of embedded systems with modern web technologies, delivering industrial-grade performance with user-friendly interfaces.\n",
    "code": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),y=(t,n)=>{for(var i in n)o(t,i,{get:n[i],enumerable:!0})},a=(t,n,i,l)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of m(n))!f.call(t,r)&&r!==i&&o(t,r,{get:()=>n[r],enumerable:!(l=p(n,r))||l.enumerable});return t};var b=(t,n,i)=>(i=t!=null?u(g(t)):{},a(n||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=>a(o({},\"__esModule\",{value:!0}),t);var s=v((T,c)=>{c.exports=_jsx_runtime});var P={};y(P,{default:()=>h,frontmatter:()=>I});var e=b(s()),I={slug:\"embedded-pid-controller\",title:\"Embedded PID Controller System\",summary:\"A real-time PID controller implementation for industrial automation with advanced tuning algorithms and web-based configuration interface.\",role:\"Embedded Systems Developer & Firmware Engineer\",dates:\"September 2023 - December 2023\",tech:[\"C\",\"FreeRTOS\",\"ARM Cortex-M4\",\"WebSockets\",\"Python\",\"Flask\",\"React\"],status:\"Completed\",heroImage:\"/images/projects/pid-controller-hero.jpg\",repoUrl:\"https://github.com/danielog/embedded-pid-controller\",liveUrl:\"https://pid-controller-demo.vercel.app\",featured:!0,tags:[\"embedded\",\"c\",\"freertos\",\"python\",\"react\",\"control systems\"],metrics:[{label:\"Control Frequency\",value:\"1kHz\"},{label:\"Response Time\",value:\"Less than 1ms\"},{label:\"Accuracy\",value:\"\\xB10.1%\"}],screenshots:[{src:\"/images/projects/pid-controller-1.jpg\",alt:\"Hardware Setup\",caption:\"Embedded controller board with industrial sensors\"},{src:\"/images/projects/pid-controller-2.jpg\",alt:\"Web Interface\",caption:\"Real-time monitoring and configuration interface\"},{src:\"/images/projects/pid-controller-3.jpg\",alt:\"Tuning Dashboard\",caption:\"Advanced PID tuning with auto-calibration features\"}]};function d(t){let n={code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...t.components},{Callout:i}=n;return i||C(\"Callout\",!0),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"Project Overview\"}),`\n`,(0,e.jsx)(n.p,{children:\"The Embedded PID Controller System is a high-performance real-time control solution designed for industrial automation. It combines low-level embedded programming with modern web technologies to provide precise control with intuitive configuration interfaces.\"}),`\n`,(0,e.jsx)(n.h2,{children:\"The Challenge\"}),`\n`,(0,e.jsx)(n.p,{children:\"Industrial processes require precise control with:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Sub-millisecond response times\"}),`\n`,(0,e.jsx)(n.li,{children:\"High-frequency control loops (1kHz+)\"}),`\n`,(0,e.jsx)(n.li,{children:\"Real-time monitoring and adjustment\"}),`\n`,(0,e.jsx)(n.li,{children:\"Robust communication protocols\"}),`\n`,(0,e.jsx)(n.li,{children:\"Easy configuration and tuning\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"System Architecture\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Hardware Layer\"}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Microcontroller\"}),\": ARM Cortex-M4 with FPU\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"168 MHz clock speed for high-performance computing\"}),`\n`,(0,e.jsx)(n.li,{children:\"Hardware floating-point unit for precise calculations\"}),`\n`,(0,e.jsx)(n.li,{children:\"Multiple ADC channels for sensor inputs\"}),`\n`,(0,e.jsx)(n.li,{children:\"PWM outputs for actuator control\"}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Communication Interface\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Ethernet connectivity for network communication\"}),`\n`,(0,e.jsx)(n.li,{children:\"Serial interfaces for legacy system integration\"}),`\n`,(0,e.jsx)(n.li,{children:\"Modbus RTU/TCP protocol support\"}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Firmware (C + FreeRTOS)\"}),`\n`,(0,e.jsx)(n.p,{children:\"The embedded firmware was developed using C with FreeRTOS for real-time task management:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-c\",children:`// PID controller task\nvoid PID_Control_Task(void *pvParameters) {\n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    const TickType_t xFrequency = pdMS_TO_TICKS(1); // 1kHz\n    \n    while(1) {\n        // Read sensor values\n        float setpoint = getSetpoint();\n        float process_value = readSensor();\n        \n        // Calculate PID output\n        float output = calculatePID(setpoint, process_value);\n        \n        // Apply output to actuator\n        setActuatorOutput(output);\n        \n        // Send telemetry data\n        sendTelemetryData(setpoint, process_value, output);\n        \n        vTaskDelayUntil(&xLastWakeTime, xFrequency);\n    }\n}\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Web Interface (React + Flask)\"}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Backend (Python Flask)\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"RESTful API for configuration and monitoring\"}),`\n`,(0,e.jsx)(n.li,{children:\"WebSocket server for real-time data streaming\"}),`\n`,(0,e.jsx)(n.li,{children:\"Database integration for historical data storage\"}),`\n`,(0,e.jsx)(n.li,{children:\"Authentication and authorization system\"}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Frontend (React)\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Real-time data visualization with Chart.js\"}),`\n`,(0,e.jsx)(n.li,{children:\"Interactive PID parameter tuning interface\"}),`\n`,(0,e.jsx)(n.li,{children:\"System configuration and calibration tools\"}),`\n`,(0,e.jsx)(n.li,{children:\"Responsive design for mobile and desktop\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Key Features\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Real-time Control\"}),`\n`,(0,e.jsx)(i,{type:\"info\",children:(0,e.jsx)(n.p,{children:\"The system maintains 1kHz control frequency with consistent timing accuracy.\"})}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"High-frequency Control Loop\"}),\": 1kHz sampling rate with less than 1ms response time\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Multiple PID Channels\"}),\": Support for up to 8 independent control loops\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Advanced Tuning\"}),\": Auto-tuning algorithms with manual override options\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Safety Features\"}),\": Watchdog timers and fault detection\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Communication & Monitoring\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"WebSocket Integration\"}),\": Real-time bidirectional communication\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"RESTful API\"}),\": Standard HTTP endpoints for configuration\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Modbus Support\"}),\": Integration with existing industrial systems\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Data Logging\"}),\": Historical data storage and analysis\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"User Interface\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Real-time Visualization\"}),\": Live charts showing setpoint, process value, and output\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Parameter Tuning\"}),\": Interactive sliders for PID gains (Kp, Ki, Kd)\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"System Configuration\"}),\": Easy setup for different process types\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Alarm Management\"}),\": Configurable alerts and notifications\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Technical Implementation\"}),`\n`,(0,e.jsx)(n.h3,{children:\"PID Algorithm Implementation\"}),`\n`,(0,e.jsx)(n.p,{children:\"The PID controller uses a modified algorithm with derivative kick prevention:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-c\",children:`typedef struct {\n    float Kp, Ki, Kd;\n    float setpoint;\n    float last_error;\n    float integral;\n    float derivative;\n    float output_min, output_max;\n} PIDController;\n\nfloat calculatePID(PIDController* pid, float process_value) {\n    float error = pid->setpoint - process_value;\n    \n    // Proportional term\n    float P = pid->Kp * error;\n    \n    // Integral term with windup protection\n    pid->integral += error * dt;\n    if (pid->integral > integral_max) pid->integral = integral_max;\n    if (pid->integral < integral_min) pid->integral = integral_min;\n    float I = pid->Ki * pid->integral;\n    \n    // Derivative term (derivative on measurement)\n    float D = -pid->Kd * (process_value - pid->last_process_value) / dt;\n    \n    // Calculate output\n    float output = P + I + D;\n    \n    // Apply output limits\n    if (output > pid->output_max) output = pid->output_max;\n    if (output < pid->output_min) output = pid->output_min;\n    \n    pid->last_error = error;\n    pid->last_process_value = process_value;\n    \n    return output;\n}\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"WebSocket Communication\"}),`\n`,(0,e.jsx)(n.p,{children:\"Real-time data streaming between embedded system and web interface:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-javascript\",children:`// WebSocket client for real-time updates\nconst ws = new WebSocket('ws://controller.local:8080/ws');\n\nws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    updateChart(data);\n    updatePIDDisplay(data);\n};\n\n// Send configuration updates\nfunction updatePIDParameters(params) {\n    ws.send(JSON.stringify({\n        type: 'config_update',\n        data: params\n    }));\n}\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Performance Results\"}),`\n`,(0,e.jsx)(n.p,{children:\"The system achieved excellent performance metrics:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Control Frequency\"}),\": Consistent 1kHz execution\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Response Time\"}),\": Less than 1ms from sensor reading to output\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Accuracy\"}),\": \\xB10.1% steady-state error\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Stability\"}),\": Robust performance across varying load conditions\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Integration & Deployment\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Industrial Integration\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Modbus Protocol\"}),\": Seamless integration with existing SCADA systems\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Legacy Support\"}),\": Backward compatibility with older control systems\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Network Configuration\"}),\": Flexible IP and communication settings\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Remote Access\"}),\": Secure web-based configuration and monitoring\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Quality Assurance\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Extensive Testing\"}),\": Unit tests, integration tests, and field trials\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Documentation\"}),\": Comprehensive user manuals and technical specifications\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Certification\"}),\": CE marking and industrial safety compliance\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Support\"}),\": Long-term maintenance and technical support\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Lessons Learned\"}),`\n`,(0,e.jsx)(n.p,{children:\"This project provided valuable insights into:\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Real-time Systems\"}),\": Timing constraints and deterministic behavior\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Embedded Programming\"}),\": Low-level optimization and resource management\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Industrial Protocols\"}),\": Modbus integration and industrial communication\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Full-stack Development\"}),\": Bridging embedded systems with modern web technologies\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Future Enhancements\"}),`\n`,(0,e.jsx)(n.p,{children:\"Potential improvements for future versions:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Machine Learning\"}),\": Adaptive PID tuning using ML algorithms\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Edge Computing\"}),\": Local AI processing for predictive control\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Cloud Integration\"}),\": Remote monitoring and analytics platform\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Advanced Algorithms\"}),\": Model predictive control (MPC) implementation\"]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"The project demonstrates the successful integration of embedded systems with modern web technologies, delivering industrial-grade performance with user-friendly interfaces.\"})]})}function h(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,{...t,children:(0,e.jsx)(d,{...t})}):d(t)}function C(t,n){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return w(P);})();\n;return Component;"
  },
  "_id": "projects/embedded-pid-controller.mdx",
  "_raw": {
    "sourceFilePath": "projects/embedded-pid-controller.mdx",
    "sourceFileName": "embedded-pid-controller.mdx",
    "sourceFileDir": "projects",
    "contentType": "mdx",
    "flattenedPath": "projects/embedded-pid-controller"
  },
  "type": "Project",
  "url": "/projects/embedded-pid-controller"
}